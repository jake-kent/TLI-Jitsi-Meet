{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///do_external_connect.min.js","webpack:///webpack/bootstrap 0a23e713c09eed009cb4","webpack:///./connection_optimization/do_external_connect.js","webpack:///./react/features/base/config/getRoomName.js","webpack:///./react/features/base/config/parseURLParams.js"],"names":["root","factory","exports","module","define","amd","a","i","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","checkForConnectHandlerAndConnect","window","APP","connect","status","handler","errorCallback","error","console","warn","XMPPAttachInfo","_getRoomName","_getRoomName2","_parseURLParams","_parseURLParams2","createConnectionExternally","url","location","config","externalConnectUrl","roomName","token","jwt","connectionInfo","data","getRoomName","getroomnode","path","pathname","substring","lastIndexOf","toLowerCase","undefined","Object","defineProperty","value","parseURLParams","dontParse","arguments","length","source","paramStr","search","hash","params","substr","split","forEach","part","param","key","JSON","parse","decodeURIComponent","replace","e","msg","String","onerror"],"mappings":"CAAA,SAAAA,EAAAC,GACA,mBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,QACA,sBAAAG,gBAAAC,IACAD,UAAAH,OACA,CACA,GAAAK,GAAAL,GACA,QAAAM,KAAAD,IAAA,gBAAAJ,iBAAAF,GAAAO,GAAAD,EAAAC,KAECC,KAAA,WACD,MCAgB,UAAUC,GCN1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAT,OAGA,IAAAC,GAAAS,EAAAD,IACAT,WACAW,GAAAF,EACAG,UAUA,OANAL,GAAAE,GAAAI,KAAAZ,EAAAD,QAAAC,IAAAD,QAAAQ,GAGAP,EAAAW,UAGAX,EAAAD,QAvBA,GAAAU,KAqCA,OATAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,SAGAR,EAAA,KDgBM,SAASP,EAAQD,EAASQ,GAE/B,YAUA,SAASS,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,QAASF,GEPxF,QAASG,KACLC,OAAOC,KAC8B,UAA9BD,OAAOC,IAAIC,QAAQC,QACnBH,OAAOC,IAAIC,QAAQE,UAS9B,QAASC,GAAcC,GAEnBA,GAASC,QAAQC,KAAKF,GAItBN,OAAOS,gBACHN,OAAQ,SAEZJ,IA9EJ,GAAAW,GAAAxB,EAAA,GF0DKyB,EAAgBhB,EAAuBe,GEzD5CE,EAAA1B,EAAA,GF6DK2B,EAAmBlB,EAAuBiB,EE/C/C,IAA0C,kBAA/BE,4BAA2C,CAElD,GAAIC,MACEF,EAAAf,SAAeE,OAAOgB,YAAgB,QAChC,8BACDC,OAAOC,mBACdC,QAEJ,IAAIJ,IAAQI,KAAWR,EAAAb,YAAgB,CACnCiB,YAAgBI,CAEhB,IAAMC,MAAQP,EAAAf,SAAeE,OAAOgB,YAAgB,UAAUK,GAE1DD,KACAL,aAAiBK,GAGrBN,2BACIC,EACA,SAAAO,GAGItB,OAAOS,gBACHN,OAAQ,UACRoB,KAAMD,GAEVvB,KAEJM,OAEJA,SAGJA,MF4FE,SAAS1B,EAAQD,GAEtB,YGvIc,SAAS8C,KAAuB,GACnCC,GAAgBR,OAAhBQ,YACFC,EAAO1B,OAAOgB,SAASW,SACzBR,QAeJ,OAXIA,GADAM,GAAsC,kBAAhBA,GACXA,EAAYlC,KAAK0B,OAAQS,GAO9BA,EAAKE,UAAUF,EAAKG,YAAY,KAAO,GAAGC,eACrCC,OH0HlBC,OAAOC,eAAevD,EAAS,cAC3BwD,WAEJxD,EAAQoB,QG5Ie0B,GH0KlB,SAAS7C,EAAQD,GAEtB,YIzKc,SAASyD,GAChBpB,GAEiC,GADjCqB,GACiCC,UAAAC,OAAA,GAAAP,SAAAM,UAAA,IAAAA,UAAA,GAAjCE,EAAiCF,UAAAC,OAAA,GAAAP,SAAAM,UAAA,GAAAA,UAAA,GAAhB,OACfG,EAAsB,WAAXD,EAAsBxB,EAAI0B,OAAS1B,EAAI2B,KAClDC,IA8BN,OA3BAH,IAAYA,EAASI,OAAO,GAAGC,MAAM,KAAKC,QAAQ,SAAAC,GAC9C,GAAMC,GAAQD,EAAKF,MAAM,KACnBI,EAAMD,EAAM,EAElB,IAAKC,EAAL,CAIA,GAAIf,SAEJ,KACIA,EAAQc,EAAM,GACTZ,IACDF,EACMgB,KAAKC,MAAMC,mBAAmBlB,GAAOmB,QAAQ,MAAO,OAEhE,MAAOC,GACL,GAAMC,2CAA8CC,OAAOtB,EAK3D,OAHA3B,SAAQC,KAAK+C,EAAKD,QAClBtD,OAAOyD,SAAWzD,OAAOyD,QAAQF,EAAK,KAAM,KAAM,KAAMD,IAI5DX,EAAOM,GAAOf,KAGXS,EJwIVX,OAAOC,eAAevD,EAAS,cAC3BwD,WAEJxD,EAAQoB,QI9KeqC","file":"do_external_connect.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/libs/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _getRoomName = __webpack_require__(1);\n\t\n\tvar _getRoomName2 = _interopRequireDefault(_getRoomName);\n\t\n\tvar _parseURLParams = __webpack_require__(2);\n\t\n\tvar _parseURLParams2 = _interopRequireDefault(_parseURLParams);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\n\t * Implements external connect using createConnectionExternally function defined\n\t * in external_connect.js for Jitsi Meet. Parses the room name and JSON Web\n\t * Token (JWT) from the URL and executes createConnectionExternally.\n\t *\n\t * NOTE: If you are using lib-jitsi-meet without Jitsi Meet, you should use this\n\t * file as reference only because the implementation is Jitsi Meet-specific.\n\t *\n\t * NOTE: For optimal results this file should be included right after\n\t * external_connect.js.\n\t */\n\t\n\t/* global config, createConnectionExternally */\n\t\n\tif (typeof createConnectionExternally === 'function') {\n\t    // URL params have higher proirity than config params.\n\t    var url = (0, _parseURLParams2.default)(window.location, true, 'hash')['config.externalConnectUrl'] || config.externalConnectUrl;\n\t    var roomName = void 0;\n\t\n\t    if (url && (roomName = (0, _getRoomName2.default)())) {\n\t        url += '?room=' + roomName;\n\t\n\t        var token = (0, _parseURLParams2.default)(window.location, true, 'search').jwt;\n\t\n\t        if (token) {\n\t            url += '&token=' + token;\n\t        }\n\t\n\t        createConnectionExternally(url, function (connectionInfo) {\n\t            // Sets that global variable to be used later by connect method\n\t            // in connection.js.\n\t            window.XMPPAttachInfo = {\n\t                status: 'success',\n\t                data: connectionInfo\n\t            };\n\t            checkForConnectHandlerAndConnect();\n\t        }, errorCallback);\n\t    } else {\n\t        errorCallback();\n\t    }\n\t} else {\n\t    errorCallback();\n\t}\n\t\n\t/**\n\t * Check if connect from connection.js was executed and executes the handler\n\t * that is going to finish the connect work.\n\t *\n\t * @returns {void}\n\t */\n\tfunction checkForConnectHandlerAndConnect() {\n\t    window.APP && window.APP.connect.status === 'ready' && window.APP.connect.handler();\n\t}\n\t\n\t/**\n\t * Implements a callback to be invoked if anything goes wrong.\n\t *\n\t * @param {Error} error - The specifics of what went wrong.\n\t * @returns {void}\n\t */\n\tfunction errorCallback(error) {\n\t    // The value of error is undefined if external connect is disabled.\n\t    error && console.warn(error);\n\t\n\t    // Sets that global variable to be used later by connect method in\n\t    // connection.js.\n\t    window.XMPPAttachInfo = {\n\t        status: 'error'\n\t    };\n\t    checkForConnectHandlerAndConnect();\n\t}\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = getRoomName;\n\t\n\t\n\t/**\n\t * Builds and returns the room name.\n\t *\n\t * @returns {string}\n\t */\n\tfunction getRoomName() {\n\t    var getroomnode = config.getroomnode;\n\t\n\t    var path = window.location.pathname;\n\t    var roomName = void 0;\n\t\n\t    // Determine the room node from the URL.\n\t    if (getroomnode && typeof getroomnode === 'function') {\n\t        roomName = getroomnode.call(config, path);\n\t    } else {\n\t        // Fall back to the default strategy of making assumptions about how the\n\t        // URL maps to the room (name). It currently assumes a deployment in\n\t        // which the last non-directory component of the path (name) is the\n\t        // room.\n\t        roomName = path.substring(path.lastIndexOf('/') + 1).toLowerCase() || undefined;\n\t    }\n\t\n\t    return roomName;\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = parseURLParams;\n\t\n\t\n\t/**\n\t * Parses the parameters from the URL and returns them as a JS object.\n\t *\n\t * @param {string} url - URL to parse.\n\t * @param {boolean} dontParse - If false or undefined some transformations\n\t * (for parsing the value as JSON) are going to be executed.\n\t * @param {string} source - Values - \"hash\"/\"search\" if \"search\" the parameters\n\t * will parsed from location.search otherwise from location.hash.\n\t * @returns {Object}\n\t */\n\tfunction parseURLParams(url) {\n\t    var dontParse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\t    var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'hash';\n\t\n\t    var paramStr = source === 'search' ? url.search : url.hash;\n\t    var params = {};\n\t\n\t    // eslint-disable-next-line newline-per-chained-call\n\t    paramStr && paramStr.substr(1).split('&').forEach(function (part) {\n\t        var param = part.split('=');\n\t        var key = param[0];\n\t\n\t        if (!key) {\n\t            return;\n\t        }\n\t\n\t        var value = void 0;\n\t\n\t        try {\n\t            value = param[1];\n\t            if (!dontParse) {\n\t                value = JSON.parse(decodeURIComponent(value).replace(/\\\\&/, '&'));\n\t            }\n\t        } catch (e) {\n\t            var msg = 'Failed to parse URL parameter value: ' + String(value);\n\t\n\t            console.warn(msg, e);\n\t            window.onerror && window.onerror(msg, null, null, null, e);\n\t\n\t            return;\n\t        }\n\t        params[key] = value;\n\t    });\n\t\n\t    return params;\n\t}\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// do_external_connect.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/libs/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 0a23e713c09eed009cb4","/* global config, createConnectionExternally */\n\nimport getRoomName from '../react/features/base/config/getRoomName';\nimport parseURLParams from '../react/features/base/config/parseURLParams';\n\n/**\n * Implements external connect using createConnectionExternally function defined\n * in external_connect.js for Jitsi Meet. Parses the room name and JSON Web\n * Token (JWT) from the URL and executes createConnectionExternally.\n *\n * NOTE: If you are using lib-jitsi-meet without Jitsi Meet, you should use this\n * file as reference only because the implementation is Jitsi Meet-specific.\n *\n * NOTE: For optimal results this file should be included right after\n * external_connect.js.\n */\n\nif (typeof createConnectionExternally === 'function') {\n    // URL params have higher proirity than config params.\n    let url\n        = parseURLParams(window.location, true, 'hash')[\n                'config.externalConnectUrl']\n            || config.externalConnectUrl;\n    let roomName;\n\n    if (url && (roomName = getRoomName())) {\n        url += `?room=${roomName}`;\n\n        const token = parseURLParams(window.location, true, 'search').jwt;\n\n        if (token) {\n            url += `&token=${token}`;\n        }\n\n        createConnectionExternally(\n            url,\n            connectionInfo => {\n                // Sets that global variable to be used later by connect method\n                // in connection.js.\n                window.XMPPAttachInfo = {\n                    status: 'success',\n                    data: connectionInfo\n                };\n                checkForConnectHandlerAndConnect();\n            },\n            errorCallback);\n    } else {\n        errorCallback();\n    }\n} else {\n    errorCallback();\n}\n\n/**\n * Check if connect from connection.js was executed and executes the handler\n * that is going to finish the connect work.\n *\n * @returns {void}\n */\nfunction checkForConnectHandlerAndConnect() {\n    window.APP\n        && window.APP.connect.status === 'ready'\n        && window.APP.connect.handler();\n}\n\n/**\n * Implements a callback to be invoked if anything goes wrong.\n *\n * @param {Error} error - The specifics of what went wrong.\n * @returns {void}\n */\nfunction errorCallback(error) {\n    // The value of error is undefined if external connect is disabled.\n    error && console.warn(error);\n\n    // Sets that global variable to be used later by connect method in\n    // connection.js.\n    window.XMPPAttachInfo = {\n        status: 'error'\n    };\n    checkForConnectHandlerAndConnect();\n}\n\n\n\n// WEBPACK FOOTER //\n// ./connection_optimization/do_external_connect.js","/* @flow */\n\ndeclare var config: Object;\n\n/**\n * Builds and returns the room name.\n *\n * @returns {string}\n */\nexport default function getRoomName(): ?string {\n    const { getroomnode } = config;\n    const path = window.location.pathname;\n    let roomName;\n\n    // Determine the room node from the URL.\n    if (getroomnode && typeof getroomnode === 'function') {\n        roomName = getroomnode.call(config, path);\n    } else {\n        // Fall back to the default strategy of making assumptions about how the\n        // URL maps to the room (name). It currently assumes a deployment in\n        // which the last non-directory component of the path (name) is the\n        // room.\n        roomName\n            = path.substring(path.lastIndexOf('/') + 1).toLowerCase()\n                || undefined;\n    }\n\n    return roomName;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./react/features/base/config/getRoomName.js","/* @flow */\n\n/**\n * Parses the parameters from the URL and returns them as a JS object.\n *\n * @param {string} url - URL to parse.\n * @param {boolean} dontParse - If false or undefined some transformations\n * (for parsing the value as JSON) are going to be executed.\n * @param {string} source - Values - \"hash\"/\"search\" if \"search\" the parameters\n * will parsed from location.search otherwise from location.hash.\n * @returns {Object}\n */\nexport default function parseURLParams(\n        url: URL,\n        dontParse: boolean = false,\n        source: string = 'hash'): Object {\n    const paramStr = source === 'search' ? url.search : url.hash;\n    const params = {};\n\n    // eslint-disable-next-line newline-per-chained-call\n    paramStr && paramStr.substr(1).split('&').forEach(part => {\n        const param = part.split('=');\n        const key = param[0];\n\n        if (!key) {\n            return;\n        }\n\n        let value;\n\n        try {\n            value = param[1];\n            if (!dontParse) {\n                value\n                    = JSON.parse(decodeURIComponent(value).replace(/\\\\&/, '&'));\n            }\n        } catch (e) {\n            const msg = `Failed to parse URL parameter value: ${String(value)}`;\n\n            console.warn(msg, e);\n            window.onerror && window.onerror(msg, null, null, null, e);\n\n            return;\n        }\n        params[key] = value;\n    });\n\n    return params;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./react/features/base/config/parseURLParams.js"],"sourceRoot":""}